<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Pixel Matrix Editor</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: white;
            overflow-y: auto;
            padding: 10px 0;
        }
        .wrapper {
            display: flex;
            flex-direction: row;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        .color-panel {
            width: 220px;
            position: absolute;
            left: 20px;
            top: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f9f9f9;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            max-height: calc(100vh - 170px);
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
        }
        .color-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        .color-section {
            margin: 2px 0;
            width: 100%;
            max-width: 1200px;
        }
        .controls, .toolbar, .image-settings, .character-settings, .pixel-settings {
            width: 100%;
            max-width: 1200px;
            margin: 2px auto;
            overflow-x: auto;
            white-space: nowrap;
        }
        .controls label, .controls input, .controls button {
            margin: 0 5px;
            font-size: 14px;
        }
        .controls input[type="number"] {
            width: 60px;
        }
        .toolbar button, .toolbar select {
            padding: 3px 8px;
            font-size: 12px;
            margin: 0 3px;
        }
        .image-settings label, .image-settings button,
        .character-settings label, .character-settings input, .character-settings button,
        .pixel-settings label, .pixel-settings button {
            margin: 0 5px;
            font-size: 14px;
        }
        .character-settings input[type="number"],
        .pixel-settings input[type="number"] {
            width: 60px;
        }
        .character-settings input[type="range"] {
            width: 100px;
        }
        .color-button {
            position: relative;
            width: 100%;
            min-width: 200px;
            height: 28px;
            border: 1px solid black;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
            padding-right: 30px;
            box-sizing: border-box;
            transition: opacity 0.3s ease;
        }
        .color-button.inactive {
            opacity: 0.5;
        }
        .color-button .active-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 2px;
            margin-right: 5px;
            transition: background-color 0.3s ease;
        }
        .color-button .active-btn.inactive {
            background-color: #f44336;
            color: white;
        }
        .color-button .delete-btn {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(255, 0, 0, 0.2);
            border: 1px solid red;
            color: red;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .color-button .index-label {
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 1px black;
            margin-right: 5px;
            width: 20px;
            text-align: center;
        }
        .color-button .custom-label-input {
            width: 40px;
            height: 16px;
            font-size: 14px;
            padding: 0 2px;
            border: 1px solid #ccc;
            border-radius: 2px;
            text-align: center;
            margin-right: 5px;
        }
        .color-button .hex-value {
            font-size: 14px;
            color: black;
            flex-grow: 1;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #eraseButton {
            width: 100%;
            height: 24px;
            border: 1px solid black;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
            text-align: center;
            line-height: 24px;
            margin-top: 5px;
            transition: transform 0.1s ease;
        }
        #eraseButton:active {
            transform: scale(0.95);
        }
        .container {
            position: relative;
            background-color: #f0f0f0;
            overflow: hidden;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            flex: 1;
            margin-left: 240px;
        }
        .background-image {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: move;
        }
        .matrix {
            display: grid;
            border: 0.5px solid black;
            position: absolute;
            z-index: 2;
        }
        .pixel {
            border: 0.5px solid black;
            box-sizing: border-box;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pixel .character {
            position: absolute;
            font-size: 12px;
            font-family: Arial, sans-serif;
            color: black;
            pointer-events: none;
            opacity: 1;
            white-space: nowrap;
        }
        .grid-hidden .matrix {
            border: none;
        }
        .grid-hidden .pixel {
            border: none;
        }
    </style>
</head>
<body>
    <div class="color-section">
        <label>Enter Hex Color or List: </label>
        <textarea id="colorInput" rows="4" cols="20" placeholder="#FFCC98
#FFFF01
#FFAF00 (one per line)"></textarea>
        <button onclick="addColor()">Add Color</button>
        <button onclick="insertColorList()">Insert List</button>
    </div>
    <div class="controls">
        <label>Width (inch): </label>
        <input type="number" id="totalWidthInch" value="8.5" min="1" step="0.1">
        <label>Height (inch): </label>
        <input type="number" id="totalHeightInch" value="11" min="1" step="0.1">
        <label>Bleed (inch): </label>
        <input type="number" id="bleedInch" value="0.5" min="0" step="0.1">
        <label>Columns: </label>
        <input type="number" id="widthInput" value="50" min="1" max="100">
        <label>Rows: </label>
        <input type="number" id="heightInput" value="65" min="1" max="100">
        <button onclick="createMatrix()">Create Matrix</button>
    </div>
    <div class="toolbar">
        <button onclick="zoomIn()">Zoom In (Grid)</button>
        <button onclick="zoomOut()">Zoom Out (Grid)</button>
        <button id="toggleGrid" onclick="toggleGrid()">Hide Grid</button>
        <button onclick="resetPixels()">Reset Matrix</button>
        <button onclick="undo()">Undo</button>
        <button onclick="redo()">Redo</button>
    </div>
    <div class="image-settings">
        <h3>Image Settings</h3>
        <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="insertImage()">
        <button onclick="document.getElementById('imageInput').click()">Insert Image</button>
        <label>Opacity: </label>
        <input type="range" id="opacityInput" min="0" max="1" step="0.1" value="0.5" onchange="adjustOpacity()">
        <button onclick="removeImage()">Remove Image</button>
        <button onclick="zoomImageIn()">Zoom In (Image)</button>
        <button onclick="zoomImageOut()">Zoom Out (Image)</button>
        <button onclick="convertImageToPixels()">Convert Image</button>
        <select id="saveFormat">
            <option value="">Select Format</option>
            <option value="svg">SVG</option>
            <option value="png">PNG</option>
            <option value="jpg">JPG</option>
            <option value="pdf">PDF</option>
        </select>
        <label>File Name: </label>
        <input type="text" id="fileNameInput" placeholder="pixel_grid" style="width: 120px;">
        <button onclick="saveFile()">Export</button>
    </div>
    <div class="character-settings">
        <h3>Character Settings</h3>
        <button id="markCharactersBtn" onclick="markCharacters()">Mark Characters</button>
        <label>Font Size (px): </label>
        <input type="number" id="fontSizeInput" value="12" min="8" max="20" step="1" onchange="updateCharacterSize()">
        <label>Opacity: </label>
        <input type="range" id="capacityInput" min="0" max="1" step="0.1" value="1" onchange="updateCharacterCapacity()">
        <button id="toggleCharactersBtn" onclick="toggleCharacters()">Toggle Characters</button>
    </div>
    <div class="pixel-settings">
        <h3>Pixel Settings</h3>
        <button id="togglePixelColorsBtn" onclick="togglePixelColors()">Toggle Pixel Colors</button>
    </div>
    <div class="wrapper">
        <div class="color-panel" id="colorPanel">
            <div class="color-list" id="colorList"></div>
            <button id="eraseButton" onclick="currentColor = null">Erase Color</button>
        </div>
        <div class="container" id="container">
            <img id="backgroundImage" class="background-image" style="display: none;">
            <div class="matrix" id="matrix"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        const { jsPDF } = window.jspdf;
        const container = document.getElementById('container');
        const matrix = document.getElementById('matrix');
        const colorList = document.getElementById('colorList');
        const colorPanel = document.getElementById('colorPanel');
        const backgroundImage = document.getElementById('backgroundImage');
        const toggleGridButton = document.getElementById('toggleGrid');
        const markCharactersBtn = document.getElementById('markCharactersBtn');
        const toggleCharactersBtn = document.getElementById('toggleCharactersBtn');
        const togglePixelColorsBtn = document.getElementById('togglePixelColorsBtn');
        let zoomLevel = 1;
        let imageZoomLevel = 1;
        let currentLeft = 0;
        let currentTop = 0;
        let imageLeft = 0;
        let imageTop = 0;
        let currentColor = null;
        let isDrawing = false;
        let isDraggingImage = false;
        let isDraggingPanel = false;
        let isGridVisible = true;
        let isCharactersVisible = true;
        let isPixelColorsVisible = true;
        let colorArray = [];
        let customLabels = [];
        let isActiveArray = [];
        const maxColors = 29;

        let history = [];
        let historyIndex = -1;
        let initialState = null;

        let startX = 0;
        let startY = 0;
        let initialLeft = 0;
        let initialTop = 0;

        colorPanel.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
                isDraggingPanel = true;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = parseFloat(colorPanel.style.left) || 20;
                initialTop = parseFloat(colorPanel.style.top) || 150;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingPanel) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                let newLeft = initialLeft + deltaX;
                let newTop = initialTop + deltaY;

                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const pageHeight = document.documentElement.scrollHeight;
                const panelWidth = colorPanel.offsetWidth;
                const panelHeight = colorPanel.offsetHeight;
                const scrollY = window.scrollY;

                newLeft = Math.max(0, Math.min(newLeft, windowWidth - panelWidth));
                newTop = Math.max(0, Math.min(newTop, pageHeight - panelHeight));
                newTop = Math.max(scrollY, newTop);

                colorPanel.style.left = `${newLeft}px`;
                colorPanel.style.top = `${newTop}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingPanel = false;
        });

        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb.toUpperCase();
            const rgbValues = rgb.match(/\d+/g);
            if (!rgbValues || rgbValues.length < 3) return '#000000';
            const r = parseInt(rgbValues[0]).toString(16).padStart(2, '0');
            const g = parseInt(rgbValues[1]).toString(16).padStart(2, '0');
            const b = parseInt(rgbValues[2]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`.toUpperCase();
        }

        function saveState(state = null) {
            const cols = parseInt(document.getElementById('widthInput').value);
            const rows = parseInt(document.getElementById('heightInput').value);
            const pixels = matrix.children;
            const currentState = state || Array.from(pixels).map(pixel => ({
                color: pixel.style.backgroundColor || '',
                character: pixel.querySelector('.character') ? pixel.querySelector('.character').textContent : ''
            }));
            history = history.slice(0, historyIndex + 1);
            history.push(currentState);
            historyIndex = history.length - 1;
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function undo() {
            if (historyIndex <= 0) {
                alert('No more actions to undo!');
                return;
            }
            historyIndex--;
            applyState(history[historyIndex]);
        }

        function redo() {
            if (historyIndex >= history.length - 1) {
                alert('No more actions to redo!');
                return;
            }
            historyIndex++;
            applyState(history[historyIndex]);
        }

        function applyState(state) {
            const pixels = matrix.children;
            for (let i = 0; i < pixels.length; i++) {
                pixels[i].style.backgroundColor = isPixelColorsVisible ? state[i].color : '';
                const characterSpan = pixels[i].querySelector('.character');
                if (characterSpan) characterSpan.remove();
                if (state[i].character) {
                    const newCharacter = document.createElement('span');
                    newCharacter.className = 'character';
                    newCharacter.textContent = state[i].character;
                    pixels[i].appendChild(newCharacter);
                }
            }
            updateCharacterDisplay();
        }

        function createMatrix() {
            const totalWidthInch = parseFloat(document.getElementById('totalWidthInch').value);
            const totalHeightInch = parseFloat(document.getElementById('totalHeightInch').value);
            const bleedInch = parseFloat(document.getElementById('bleedInch').value);
            const cols = parseInt(document.getElementById('widthInput').value);
            const rows = parseInt(document.getElementById('heightInput').value);

            if (totalWidthInch < 1 || totalHeightInch < 1 || bleedInch < 0 || cols < 1 || rows < 1 || cols > 100 || rows > 100) {
                alert('Please enter valid values: Width/Height >= 1, Bleed >= 0, Cells from 1-100!');
                return;
            }

            const totalWidthPx = totalWidthInch * 96;
            const totalHeightPx = totalHeightInch * 96;
            const bleedPx = bleedInch * 96;

            const maxGridWidthInch = totalWidthInch - 2 * bleedInch;
            const maxGridHeightInch = totalHeightInch - 2 * bleedInch;
            const maxGridWidthPx = maxGridWidthInch * 96;
            const maxGridHeightPx = maxGridHeightInch * 96;

            if (maxGridWidthInch <= 0 || maxGridHeightInch <= 0) {
                alert('Bleed is too large compared to the total dimensions!');
                return;
            }

            const pixelSizeInchByWidth = maxGridWidthInch / cols;
            const pixelSizeInchByHeight = maxGridHeightInch / rows;
            const pixelSizeInch = Math.min(pixelSizeInchByWidth, pixelSizeInchByHeight);
            const pixelSizePx = pixelSizeInch * 96;

            const gridWidthInch = pixelSizeInch * cols;
            const gridHeightInch = pixelSizeInch * rows;
            const gridWidthPx = gridWidthInch * 96;
            const gridHeightPx = gridHeightInch * 96;

            if (gridWidthPx > maxGridWidthPx || gridHeightPx > maxGridHeightPx) {
                alert(`Grid ${cols}x${rows} is not feasible! Grid size (${gridWidthInch.toFixed(2)}x${gridHeightInch.toFixed(2)}in, ${gridWidthPx.toFixed(2)}x${gridHeightPx.toFixed(2)}px) exceeds maximum area (${maxGridWidthInch.toFixed(2)}x${maxGridHeightInch.toFixed(2)}in, ${maxGridWidthPx.toFixed(2)}x${maxGridHeightPx.toFixed(2)}px) after bleed. Reduce the number of cells or increase total dimensions!`);
                return;
            }

            currentLeft = (totalWidthPx - gridWidthPx) / 2;
            currentTop = (totalHeightPx - gridHeightPx) / 2;

            const bottomEdge = currentTop + gridHeightPx;
            const rightEdge = currentLeft + gridWidthPx;
            if (currentLeft < bleedPx || currentTop < bleedPx || bottomEdge > totalHeightPx || rightEdge > totalWidthPx) {
                alert(`Grid ${cols}x${rows} does not fit within the total area! Position: left=${currentLeft.toFixed(2)}px, top=${currentTop.toFixed(2)}px, bottom=${bottomEdge.toFixed(2)}px, right=${rightEdge.toFixed(2)}px exceeds total (${totalWidthPx}x${totalHeightPx}px) with bleed ${bleedInch}in (${bleedPx}px).`);
                return;
            }

            container.style.width = `${totalWidthPx}px`;
            container.style.height = `${totalHeightPx}px`;

            matrix.style.width = `${gridWidthPx}px`;
            matrix.style.height = `${gridHeightPx}px`;
            matrix.style.left = `${currentLeft}px`;
            matrix.style.top = `${currentTop}px`;
            matrix.style.gridTemplateColumns = `repeat(${cols}, ${pixelSizePx}px)`;
            matrix.style.gridTemplateRows = `repeat(${rows}, ${pixelSizePx}px)`;

            matrix.innerHTML = '';
            for (let i = 0; i < cols * rows; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'pixel';
                pixel.style.width = `${pixelSizePx}px`;
                pixel.style.height = `${pixelSizePx}px`;
                matrix.appendChild(pixel);
            }

            zoomLevel = 1;
            imageZoomLevel = 1;
            imageLeft = 0;
            imageTop = 0;
            updateZoomAndPosition();

            matrix.addEventListener('mousedown', (e) => {
                isDrawing = true;
                initialState = Array.from(matrix.children).map(pixel => ({
                    color: pixel.style.backgroundColor || '',
                    character: pixel.querySelector('.character') ? pixel.querySelector('.character').textContent : ''
                }));
                paintPixel(e);
            });
            matrix.addEventListener('mousemove', (e) => {
                if (isDrawing) paintPixel(e);
            });
            matrix.addEventListener('mouseup', () => {
                isDrawing = false;
                saveState();
                initialState = null;
            });
            matrix.addEventListener('mouseleave', () => {
                if (isDrawing) {
                    isDrawing = false;
                    saveState();
                    initialState = null;
                }
            });

            backgroundImage.addEventListener('mousedown', (e) => {
                if (backgroundImage.style.display !== 'none') {
                    isDraggingImage = true;
                    const rect = backgroundImage.getBoundingClientRect();
                    dragOffsetX = e.clientX - imageLeft;
                    dragOffsetY = e.clientY - imageTop;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (isDraggingImage) {
                    imageLeft = e.clientX - dragOffsetX;
                    imageTop = e.clientY - dragOffsetY;
                    updateImagePosition();
                }
            });
            document.addEventListener('mouseup', () => {
                isDraggingImage = false;
                isDraggingPanel = false;
            });

            isGridVisible = true;
            toggleGridButton.textContent = 'Hide Grid';
            container.classList.remove('grid-hidden');
            isCharactersVisible = true;
            toggleCharactersBtn.textContent = 'Hide Characters';
            isPixelColorsVisible = true;
            togglePixelColorsBtn.textContent = 'Hide Pixel Colors';
            updateCharacterDisplay();
            updatePixelColors();

            history = [];
            historyIndex = -1;
            saveState();
        }

        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function toggleGrid() {
            isGridVisible = !isGridVisible;
            if (isGridVisible) {
                toggleGridButton.textContent = 'Hide Grid';
                container.classList.remove('grid-hidden');
            } else {
                toggleGridButton.textContent = 'Show Grid';
                container.classList.add('grid-hidden');
            }
        }

        function resetImageState() {
            backgroundImage.style.display = 'none';
            backgroundImage.src = '';
            backgroundImage.onload = null;
            backgroundImage.onerror = null;
            imageZoomLevel = 1;
            imageLeft = 0;
            imageTop = 0;
            document.getElementById('imageInput').value = '';
            updateImagePosition();
        }

        function insertImage() {
            const file = document.getElementById('imageInput').files[0];
            if (!file) {
                console.log('No file selected.');
                return;
            }

            resetImageState();

            const reader = new FileReader();
            reader.onload = (e) => {
                backgroundImage.src = e.target.result;
                backgroundImage.style.display = 'block';

                backgroundImage.onload = () => {
                    backgroundImage.style.width = `${backgroundImage.naturalWidth}px`;
                    backgroundImage.style.height = `${backgroundImage.naturalHeight}px`;
                    adjustOpacity();
                    updateImagePosition();
                    console.log('Image inserted successfully:', backgroundImage.src);
                };

                backgroundImage.onerror = () => {
                    console.error('Error loading image.');
                    alert('Failed to load the image. Please try another file.');
                    resetImageState();
                };
            };
            reader.onerror = () => {
                console.error('Error reading file.');
                alert('Failed to read the image file. Please try again.');
                resetImageState();
            };
            reader.readAsDataURL(file);
        }

        function adjustOpacity() {
            const opacity = document.getElementById('opacityInput').value;
            backgroundImage.style.opacity = opacity;
        }

        function removeImage() {
            resetImageState();
        }

        function zoomImageIn() {
            if (backgroundImage.style.display !== 'none') {
                imageZoomLevel += 0.1;
                updateImagePosition();
            }
        }

        function zoomImageOut() {
            if (backgroundImage.style.display !== 'none' && imageZoomLevel > 0.2) {
                imageZoomLevel -= 0.1;
                updateImagePosition();
            }
        }

        function updateImagePosition() {
            const totalWidthPx = parseFloat(container.style.width) || 0;
            const totalHeightPx = parseFloat(container.style.height) || 0;
            const bleedPx = parseFloat(document.getElementById('bleedInch').value) * 96 || 0;

            const totalZoom = zoomLevel * imageZoomLevel;
            backgroundImage.style.transform = `scale(${totalZoom})`;
            backgroundImage.style.transformOrigin = 'top left';
            backgroundImage.style.left = `${imageLeft * zoomLevel}px`;
            backgroundImage.style.top = `${imageTop * zoomLevel}px`;

            const naturalWidth = backgroundImage.naturalWidth || 0;
            const naturalHeight = backgroundImage.naturalHeight || 0;
            const scaledWidth = naturalWidth * totalZoom;
            const scaledHeight = naturalHeight * totalZoom;

            if (imageLeft * zoomLevel < -scaledWidth + bleedPx) imageLeft = (-scaledWidth + bleedPx) / zoomLevel;
            if (imageTop * zoomLevel < -scaledHeight + bleedPx) imageTop = (-scaledHeight + bleedPx) / zoomLevel;
            if (imageLeft * zoomLevel > totalWidthPx - bleedPx) imageLeft = (totalWidthPx - bleedPx) / zoomLevel;
            if (imageTop * zoomLevel > totalHeightPx - bleedPx) imageTop = (totalHeightPx - bleedPx) / zoomLevel;

            backgroundImage.style.left = `${imageLeft * zoomLevel}px`;
            backgroundImage.style.top = `${imageTop * zoomLevel}px`;
        }

        function addColor() {
            const colorInput = document.getElementById('colorInput').value.trim();
            const firstLine = colorInput.split('\n')[0].trim();
            if (/^#[0-9A-F]{6}$/i.test(firstLine)) {
                if (colorArray.length >= maxColors) {
                    alert(`Maximum number of colors is ${maxColors}! Please remove some colors before adding more.`);
                    return;
                }
                createColorButton(firstLine);
                document.getElementById('colorInput').value = '';
            } else {
                alert('Please enter a valid hex color code (e.g., #FF0000) in the first line.');
            }
        }

        function insertColorList() {
            const colorInput = document.getElementById('colorInput').value.trim();
            if (!colorInput) {
                alert('Please enter a list of hex colors, one per line (e.g., #FF0000\n#00FF00\n#0000FF)');
                return;
            }
            const colors = colorInput.split('\n').map(color => color.trim()).filter(color => color);
            let valid = true;
            colors.forEach(color => {
                if (!/^#[0-9A-F]{6}$/i.test(color)) {
                    valid = false;
                }
            });
            if (!valid) {
                alert('All colors must be valid hex codes (e.g., #FF0000)');
                return;
            }
            if (colors.length + colorArray.length > maxColors) {
                alert(`Maximum number of colors is ${maxColors}! You can only add ${maxColors - colorArray.length} more colors.`);
                return;
            }
            colors.forEach(color => createColorButton(color));
            document.getElementById('colorInput').value = '';
        }

        function createColorButton(colorInput) {
            const button = document.createElement('button');
            button.className = 'color-button';
            button.style.backgroundColor = colorInput;
            button.onclick = () => {
                currentColor = colorInput;
                console.log(`Selected color: ${currentColor}`);
            };

            const activeBtn = document.createElement('button');
            activeBtn.className = 'active-btn';
            activeBtn.textContent = 'On';
            activeBtn.onclick = (e) => {
                e.stopPropagation();
                const isActive = activeBtn.textContent === 'On';
                activeBtn.textContent = isActive ? 'Off' : 'On';
                activeBtn.classList.toggle('inactive', !isActive);
                button.classList.toggle('inactive', !isActive);
                updateColorLabels();
            };

            const indexLabel = document.createElement('span');
            indexLabel.className = 'index-label';

            const input = document.createElement('input');
            input.className = 'custom-label-input';
            input.type = 'text';
            input.value = '';
            input.oninput = () => updateColorLabels();

            const hexValue = document.createElement('span');
            hexValue.className = 'hex-value';
            hexValue.textContent = colorInput.toUpperCase();

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'X';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                colorList.removeChild(button);
                updateColorLabels();
            };

            button.appendChild(activeBtn);
            button.appendChild(indexLabel);
            button.appendChild(input);
            button.appendChild(hexValue);
            button.appendChild(deleteBtn);
            colorList.insertBefore(button, colorList.firstChild);

            updateColorLabels();
        }

        function updateColorLabels() {
            const buttons = colorList.querySelectorAll('.color-button');
            colorArray = [];
            customLabels = [];
            isActiveArray = [];
            buttons.forEach((button, index) => {
                const color = button.style.backgroundColor;
                const hexColor = rgbToHex(color);
                const activeBtn = button.querySelector('.active-btn');
                const indexLabel = button.querySelector('.index-label');
                const input = button.querySelector('.custom-label-input');
                const hexValue = button.querySelector('.hex-value');
                colorArray.push(hexColor);
                customLabels.push(input.value.trim() || '');
                isActiveArray.push(activeBtn.textContent === 'On');
                indexLabel.textContent = (index + 1).toString();
                hexValue.textContent = hexColor;
                button.classList.toggle('inactive', activeBtn.textContent === 'Off');
                activeBtn.classList.toggle('inactive', activeBtn.textContent === 'Off');
            });
            console.log('Updated colorArray:', colorArray);
            console.log('Updated customLabels:', customLabels);
            console.log('Updated isActiveArray:', isActiveArray);
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        function findClosestColor(targetColor, colorList, activeList) {
            let minDistance = Infinity;
            let closestColor = null;
            let closestIndex = -1;
            colorList.forEach((color, index) => {
                if (!activeList[index]) return;
                const rgb = hexToRgb(color);
                const distance = Math.sqrt(
                    (targetColor[0] - rgb[0]) ** 2 +
                    (targetColor[1] - rgb[1]) ** 2 +
                    (targetColor[2] - rgb[2]) ** 2
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                    closestIndex = index;
                }
            });
            return { color: closestColor || '#FFFFFF', index: closestIndex };
        }

        function convertImageToPixels() {
            if (backgroundImage.style.display === 'none' || !backgroundImage.src) {
                alert('Please insert a valid image before converting!');
                return;
            }
            const activeColors = colorArray.filter((_, i) => isActiveArray[i]);
            if (activeColors.length === 0) {
                alert('Please add and activate at least one color before converting!');
                return;
            }

            initialState = Array.from(matrix.children).map(pixel => ({
                color: pixel.style.backgroundColor || '',
                character: pixel.querySelector('.character') ? pixel.querySelector('.character').textContent : ''
            }));

            const cols = parseInt(document.getElementById('widthInput').value);
            const rows = parseInt(document.getElementById('heightInput').value);
            const gridWidthPx = parseFloat(matrix.style.width) || 0;
            const gridHeightPx = parseFloat(matrix.style.height) || 0;
            const pixelSizePx = gridWidthPx / cols || 1;

            const matrixLeft = currentLeft;
            const matrixTop = currentTop;
            const matrixRight = matrixLeft + gridWidthPx * zoomLevel;
            const matrixBottom = matrixTop + gridHeightPx * zoomLevel;

            const totalZoom = zoomLevel * imageZoomLevel;
            const imgLeft = imageLeft * zoomLevel;
            const imgTop = imageTop * zoomLevel;
            const imgWidth = backgroundImage.naturalWidth * totalZoom || 0;
            const imgHeight = backgroundImage.naturalHeight * totalZoom || 0;
            const imgRight = imgLeft + imgWidth;
            const imgBottom = imgTop + imgHeight;

            const intersectLeft = Math.max(matrixLeft, imgLeft);
            const intersectTop = Math.max(matrixTop, imgTop);
            const intersectRight = Math.min(matrixRight, imgRight);
            const intersectBottom = Math.min(matrixBottom, imgBottom);

            if (intersectRight <= intersectLeft || intersectBottom <= intersectTop) {
                alert('The grid does not intersect with the image! Please adjust the position or size of the image.');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = backgroundImage.naturalWidth || 1;
            canvas.height = backgroundImage.naturalHeight || 1;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const newState = Array.from(matrix.children).map(pixel => ({
                color: pixel.style.backgroundColor || '',
                character: pixel.querySelector('.character') ? pixel.querySelector('.character').textContent : ''
            }));

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const pixelX = matrixLeft + (x * pixelSizePx * zoomLevel);
                    const pixelY = matrixTop + (y * pixelSizePx * zoomLevel);
                    const pixelCenterX = pixelX + (pixelSizePx * zoomLevel) / 2;
                    const pixelCenterY = pixelY + (pixelSizePx * zoomLevel) / 2;
                    const index = y * cols + x;
                    const pixel = matrix.children[index];

                    if (pixelCenterX >= intersectLeft && pixelCenterX <= intersectRight &&
                        pixelCenterY >= intersectTop && pixelCenterY <= intersectBottom) {
                        const imageX = Math.floor((pixelCenterX - imgLeft) / totalZoom);
                        const imageY = Math.floor((pixelCenterY - imgTop) / totalZoom);
                        if (imageX >= 0 && imageX < canvas.width && imageY >= 0 && imageY < canvas.height) {
                            const idx = (imageY * canvas.width + imageX) * 4;
                            const r = imageData[idx];
                            const g = imageData[idx + 1];
                            const b = imageData[idx + 2];
                            const result = findClosestColor([r, g, b], colorArray, isActiveArray);
                            if (pixel) {
                                pixel.style.backgroundColor = isPixelColorsVisible ? result.color : '';
                                newState[index].color = result.color;
                                if (result.index !== -1 && customLabels[result.index]) {
                                    let characterSpan = pixel.querySelector('.character');
                                    if (!characterSpan) {
                                        characterSpan = document.createElement('span');
                                        characterSpan.className = 'character';
                                        pixel.appendChild(characterSpan);
                                    }
                                    characterSpan.textContent = customLabels[result.index];
                                    newState[index].character = customLabels[result.index];
                                    if (!isCharactersVisible) characterSpan.style.display = 'none';
                                } else {
                                    newState[index].character = '';
                                    const characterSpan = pixel.querySelector('.character');
                                    if (characterSpan) characterSpan.remove();
                                }
                            }
                        }
                    } else {
                        if (pixel) {
                            pixel.style.backgroundColor = '';
                            newState[index].color = '';
                            newState[index].character = '';
                            const characterSpan = pixel.querySelector('.character');
                            if (characterSpan) characterSpan.remove();
                        }
                    }
                }
            }

            saveState(newState);
            initialState = null;
            console.log('Conversion completed successfully.');
        }

        function resetPixels() {
            initialState = Array.from(matrix.children).map(pixel => ({
                color: pixel.style.backgroundColor || '',
                character: pixel.querySelector('.character') ? pixel.querySelector('.character').textContent : ''
            }));
            const cols = parseInt(document.getElementById('widthInput').value);
            const rows = parseInt(document.getElementById('heightInput').value);
            const pixels = matrix.children;
            for (let i = 0; i < cols * rows; i++) {
                pixels[i].style.backgroundColor = '';
                const characterSpan = pixels[i].querySelector('.character');
                if (characterSpan) characterSpan.remove();
            }
            saveState();
            initialState = null;
        }

        function paintPixel(event) {
            const cols = parseInt(document.getElementById('widthInput').value);
            const rows = parseInt(document.getElementById('heightInput').value);
            const gridWidthPx = parseFloat(matrix.style.width);
            const gridHeightPx = parseFloat(matrix.style.height);

            const rect = matrix.getBoundingClientRect();
            const offsetX = (event.clientX - rect.left) / zoomLevel;
            const offsetY = (event.clientY - rect.top) / zoomLevel;

            const x = Math.floor((offsetX / gridWidthPx) * cols);
            const y = Math.floor((offsetY / gridHeightPx) * rows);

            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                const index = y * cols + x;
                const pixel = matrix.children[index];
                if (pixel) {
                    if (currentColor === null) {
                        pixel.style.backgroundColor = '';
                        const characterSpan = pixel.querySelector('.character');
                        if (characterSpan) characterSpan.remove();
                    } else if (currentColor) {
                        pixel.style.backgroundColor = isPixelColorsVisible ? currentColor : '';
                        const colorIndex = colorArray.indexOf(currentColor);
                        if (colorIndex !== -1 && customLabels[colorIndex] && isActiveArray[colorIndex]) {
                            let characterSpan = pixel.querySelector('.character');
                            if (!characterSpan) {
                                characterSpan = document.createElement('span');
                                characterSpan.className = 'character';
                                pixel.appendChild(characterSpan);
                            }
                            characterSpan.textContent = customLabels[colorIndex];
                            if (!isCharactersVisible) characterSpan.style.display = 'none';
                        } else {
                            const characterSpan = pixel.querySelector('.character');
                            if (characterSpan) characterSpan.remove();
                        }
                    }
                }
            }
        }

        function zoomIn() {
            zoomLevel += 0.1;
            updateZoomAndPosition();
            updateImagePosition();
        }

        function zoomOut() {
            if (zoomLevel > 0.2) {
                zoomLevel -= 0.1;
                updateZoomAndPosition();
                updateImagePosition();
            }
        }

        function updateZoomAndPosition() {
            const gridWidthPx = parseFloat(matrix.style.width);
            const gridHeightPx = parseFloat(matrix.style.height);
            const totalWidthPx = parseFloat(container.style.width);
            const totalHeightPx = parseFloat(container.style.height);
            const bleedPx = parseFloat(document.getElementById('bleedInch').value) * 96;

            matrix.style.transform = `scale(${zoomLevel})`;
            matrix.style.transformOrigin = 'top left';
            matrix.style.left = `${currentLeft}px`;
            matrix.style.top = `${currentTop}px`;

            const scaledWidth = gridWidthPx * zoomLevel;
            const scaledHeight = gridHeightPx * zoomLevel;
            const rightEdge = currentLeft + scaledWidth;
            const bottomEdge = currentTop + scaledHeight;

            if (rightEdge > totalWidthPx - bleedPx) {
                currentLeft = totalWidthPx - scaledWidth - bleedPx;
                matrix.style.left = `${currentLeft}px`;
            }
            if (bottomEdge > totalHeightPx - bleedPx) {
                currentTop = totalHeightPx - scaledHeight - bleedPx;
                matrix.style.top = `${currentTop}px`;
            }
            if (currentLeft < bleedPx) {
                currentLeft = bleedPx;
                matrix.style.left = `${currentLeft}px`;
            }
            if (currentTop < bleedPx) {
                currentTop = bleedPx;
                matrix.style.top = `${currentTop}px`;
            }
        }

        function saveFile() {
            const format = document.getElementById('saveFormat').value;
            if (!format) {
                alert('Please select a format before exporting!');
                return;
            }

            const fileNameInput = document.getElementById('fileNameInput').value.trim();
            const fileName = fileNameInput || 'pixel_grid';

            const totalWidthInch = parseFloat(document.getElementById('totalWidthInch').value);
            const totalHeightInch = parseFloat(document.getElementById('totalHeightInch').value);
            const totalWidthPx = totalWidthInch * 96;
            const totalHeightPx = totalHeightInch * 96;
            const gridWidthPx = parseFloat(matrix.style.width) || 0;
            const gridHeightPx = parseFloat(matrix.style.height) || 0;
            const pixelSizePx = gridWidthPx / parseInt(document.getElementById('widthInput').value) || 1;
            const cols = parseInt(document.getElementById('widthInput').value) || 1;
            const rows = parseInt(document.getElementById('heightInput').value) || 1;

            if (history.length === 0 || historyIndex < 0) {
                alert('No history available! Please create a matrix or make changes before exporting.');
                return;
            }

            const dpiScale = 300 / 96;
            const exportWidthPx = totalWidthPx * dpiScale;
            const exportHeightPx = totalHeightPx * dpiScale;
            const exportPixelSizePx = pixelSizePx * dpiScale;

            const canvas = document.createElement('canvas');
            canvas.width = exportWidthPx;
            canvas.height = exportHeightPx;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, exportWidthPx, exportHeightPx);

            if (backgroundImage.style.display !== 'none' && backgroundImage.src) {
                const totalZoom = zoomLevel * imageZoomLevel * dpiScale;
                ctx.globalAlpha = parseFloat(backgroundImage.style.opacity || 1);
                ctx.drawImage(backgroundImage, imageLeft * zoomLevel * dpiScale, imageTop * zoomLevel * dpiScale, backgroundImage.naturalWidth * totalZoom, backgroundImage.naturalHeight * totalZoom);
                ctx.globalAlpha = 1;
            }

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const pixel = matrix.children[y * cols + x];
                    const color = history[historyIndex][y * cols + x].color || 'none';
                    const pixelX = currentLeft * dpiScale + x * exportPixelSizePx;
                    const pixelY = currentTop * dpiScale + y * exportPixelSizePx;

                    if (isPixelColorsVisible && color && color !== 'none') {
                        ctx.fillStyle = color;
                        ctx.fillRect(pixelX, pixelY, exportPixelSizePx, exportPixelSizePx);
                    }
                    if (isGridVisible) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 0.5 * dpiScale;
                        ctx.strokeRect(pixelX, pixelY, exportPixelSizePx, exportPixelSizePx);
                    }
                    const characterSpan = pixel.querySelector('.character');
                    if (characterSpan && isCharactersVisible) {
                        ctx.fillStyle = 'black';
                        ctx.globalAlpha = parseFloat(document.getElementById('capacityInput').value) || 1;
                        ctx.font = `${parseInt(document.getElementById('fontSizeInput').value) * dpiScale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(characterSpan.textContent || '', pixelX + exportPixelSizePx / 2, pixelY + exportPixelSizePx / 2);
                        ctx.globalAlpha = 1;
                    }
                }
            }

            if (format === 'svg') {
                let svgContent = `<svg width="${totalWidthPx}" height="${totalHeightPx}" xmlns="http://www.w3.org/2000/svg">`;
                if (backgroundImage.style.display !== 'none' && backgroundImage.src) {
                    const totalZoom = zoomLevel * imageZoomLevel;
                    svgContent += `<image x="${imageLeft * zoomLevel}" y="${imageTop * zoomLevel}" width="${backgroundImage.naturalWidth * totalZoom}" height="${backgroundImage.naturalHeight * totalZoom}" href="${backgroundImage.src}" opacity="${backgroundImage.style.opacity || 1}"/>`;
                }
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const color = history[historyIndex][y * cols + x].color || 'none';
                        const pixelX = currentLeft + x * pixelSizePx;
                        const pixelY = currentTop + y * pixelSizePx;
                        svgContent += `<rect x="${pixelX}" y="${pixelY}" width="${pixelSizePx}" height="${pixelSizePx}" fill="${isPixelColorsVisible && color !== 'none' ? color : 'none'}" stroke="${isGridVisible ? 'black' : 'none'}" stroke-width="0.5"/>`;
                        const pixel = matrix.children[y * cols + x];
                        const characterSpan = pixel.querySelector('.character');
                        if (characterSpan && isCharactersVisible) {
                            svgContent += `<text x="${pixelX + pixelSizePx / 2}" y="${pixelY + pixelSizePx / 2}" font-family="Arial, sans-serif" font-size="${parseInt(document.getElementById('fontSizeInput').value)}" text-anchor="middle" dominant-baseline="middle" fill="black" opacity="${parseFloat(document.getElementById('capacityInput').value) || 1}">${characterSpan.textContent || ''}</text>`;
                        }
                    }
                }
                svgContent += '</svg>';
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}.svg`;
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'png' || format === 'jpg') {
                const mime = format === 'png' ? 'image/png' : 'image/jpeg';
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName}.${format}`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, mime);
            } else if (format === 'pdf') {
                const imgData = canvas.toDataURL('image/png');
                const doc = new jsPDF({
                    orientation: totalWidthInch > totalHeightInch ? 'landscape' : 'portrait',
                    unit: 'in',
                    format: [totalWidthInch, totalHeightInch]
                });
                doc.addImage(imgData, 'PNG', 0, 0, totalWidthInch, totalHeightInch);
                doc.save(`${fileName}.pdf`);
            }
        }

        function markCharacters() {
            const cols = parseInt(document.getElementById('widthInput').value);
            const rows = parseInt(document.getElementById('heightInput').value);
            const pixels = matrix.children;

            if (colorArray.length === 0) {
                alert('Please add at least one color to the color list before marking characters!');
                return;
            }

            initialState = Array.from(pixels).map(pixel => ({
                color: pixel.style.backgroundColor || '',
                character: pixel.querySelector('.character') ? pixel.querySelector('.character').textContent : ''
            }));

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const index = y * cols + x;
                    const pixel = pixels[index];
                    const characterSpan = pixel.querySelector('.character');
                    if (characterSpan) characterSpan.remove();

                    const color = history[historyIndex][index].color;
                    if (color) {
                        const hexColor = rgbToHex(color);
                        const colorIndex = colorArray.indexOf(hexColor);
                        if (colorIndex !== -1 && customLabels[colorIndex] && isActiveArray[colorIndex]) {
                            const newCharacterSpan = document.createElement('span');
                            newCharacterSpan.className = 'character';
                            newCharacterSpan.textContent = customLabels[colorIndex];
                            pixel.appendChild(newCharacterSpan);
                        } else if (colorIndex === -1) {
                            const rgb = hexToRgb(hexColor);
                            const result = findClosestColor(rgb, colorArray, isActiveArray);
                            if (result.index !== -1 && customLabels[result.index]) {
                                const newCharacterSpan = document.createElement('span');
                                newCharacterSpan.className = 'character';
                                newCharacterSpan.textContent = customLabels[result.index];
                                pixel.appendChild(newCharacterSpan);
                            }
                        }
                    }
                }
            }

            isCharactersVisible = true;
            toggleCharactersBtn.textContent = 'Hide Characters';
            updateCharacterDisplay();
            saveState();
            initialState = null;
            console.log('Characters marked successfully based on current colors.');
        }

        function toggleCharacters() {
            isCharactersVisible = !isCharactersVisible;
            toggleCharactersBtn.textContent = isCharactersVisible ? 'Hide Characters' : 'Show Characters';
            updateCharacterDisplay();
        }

        function updateCharacterSize() {
            const fontSize = document.getElementById('fontSizeInput').value;
            const characters = matrix.querySelectorAll('.character');
            characters.forEach(char => char.style.fontSize = `${fontSize}px`);
        }

        function updateCharacterCapacity() {
            const capacity = document.getElementById('capacityInput').value;
            const characters = matrix.querySelectorAll('.character');
            characters.forEach(char => char.style.opacity = capacity);
        }

        function updateCharacterDisplay() {
            const characters = matrix.querySelectorAll('.character');
            characters.forEach(char => {
                char.style.fontSize = `${document.getElementById('fontSizeInput').value}px`;
                char.style.opacity = document.getElementById('capacityInput').value;
                char.style.display = isCharactersVisible ? 'block' : 'none';
            });
        }

        function togglePixelColors() {
            isPixelColorsVisible = !isPixelColorsVisible;
            togglePixelColorsBtn.textContent = isPixelColorsVisible ? 'Hide Pixel Colors' : 'Show Pixel Colors';
            updatePixelColors();
        }

        function updatePixelColors() {
            const pixels = matrix.children;
            for (let i = 0; i < pixels.length; i++) {
                const color = history[historyIndex][i].color;
                pixels[i].style.backgroundColor = isPixelColorsVisible && color ? color : '';
            }
        }

        createMatrix();
    </script>
</body>
</html>